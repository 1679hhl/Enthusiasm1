<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>生动沙盒小游戏</title>
  <style>
    body {
      margin: 0; background: #222; display: flex; flex-direction: column; align-items: center; color: #fff;
      font-family: sans-serif;
    }
    canvas {
      border: 2px solid #fff;
      image-rendering: pixelated;
      background: #88cc88;
    }
    #tip { margin: 10px; font-size: 0.9em; text-align: center; }
  </style>
</head>
<body>
  <h1>🌍 沙盒物理游戏</h1>
  <canvas id="game" width="640" height="480"></canvas>
  <div id="tip">←↑→↓移动 | 鼠标点击互动 | 沙子/水/重力 | 每秒固定更新物理</div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE_SIZE = 32;
    const ROWS = 15;
    const COLS = 20;

    const BLOCKS = {
      air:   { color: "#88cc88", solid: false, gravity: false, fluid: false },
      dirt:  { color: "#8B4513", solid: true, gravity: false, fluid: false },
      stone: { color: "#555", solid: true, gravity: false, fluid: false },
      sand:  { color: "#f4d03f", solid: true, gravity: true, fluid: false },
      water: { color: "#4fc3f7", solid: false, gravity: false, fluid: true }
    };

    const map = Array.from({ length: ROWS }, (_, y) =>
      Array.from({ length: COLS }, (_, x) => (y > 11 ? "dirt" : y === 12 ? "sand" : "air"))
    );

    let player = { x: 5, y: 5, vy: 0 };

    function drawTile(x, y, type) {
      ctx.fillStyle = BLOCKS[type].color;
      ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    }

    function drawPlayer() {
      ctx.fillStyle = "#007700";
      ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      ctx.fillStyle = "#ccffcc";
      ctx.fillRect(player.x * TILE_SIZE + 8, player.y * TILE_SIZE + 8, 6, 6);
      ctx.fillRect(player.x * TILE_SIZE + 18, player.y * TILE_SIZE + 8, 6, 6);
    }

    function drawMap() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          drawTile(x, y, map[y][x]);
        }
      }
      drawPlayer();
    }

    function updatePhysics() {
      // Sand gravity
      for (let y = ROWS - 2; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          const block = map[y][x];
          if (BLOCKS[block].gravity && map[y + 1][x] === "air") {
            map[y + 1][x] = block;
            map[y][x] = "air";
          }
        }
      }

      // Fluid spread (water)
      for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          const block = map[y][x];
          if (BLOCKS[block].fluid) {
            const options = [];
            if (y + 1 < ROWS && map[y + 1][x] === "air") options.push([x, y + 1]);
            else {
              if (x > 0 && map[y][x - 1] === "air") options.push([x - 1, y]);
              if (x < COLS - 1 && map[y][x + 1] === "air") options.push([x + 1, y]);
            }
            if (options.length) {
              const [nx, ny] = options[Math.floor(Math.random() * options.length)];
              map[ny][nx] = "water";
              map[y][x] = "air";
            }
          }
        }
      }

      // Player gravity
      if (player.y + 1 < ROWS && !BLOCKS[map[player.y + 1][player.x]].solid) {
        player.vy += 0.2;
        player.y += player.vy;
        if (player.y >= ROWS - 1) player.y = ROWS - 1;
        player.y = Math.floor(player.y);
      } else {
        player.vy = 0;
      }
    }

    function isWalkable(x, y) {
      return x >= 0 && y >= 0 && x < COLS && y < ROWS && !BLOCKS[map[y][x]].solid;
    }

    window.addEventListener("keydown", e => {
      let nx = player.x, ny = player.y;
      if (e.key === "ArrowLeft") nx--;
      if (e.key === "ArrowRight") nx++;
      if (e.key === "ArrowUp") ny--;
      if (e.key === "ArrowDown") ny++;
      if (isWalkable(nx, ny)) {
        player.x = nx;
        player.y = ny;
      }
    });

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
      if (e.button === 0) {
        map[y][x] = "air";
      } else if (e.button === 2) {
        map[y][x] = ["dirt", "stone", "sand", "water"][Math.floor(Math.random() * 4)];
      }
    });
    canvas.oncontextmenu = e => e.preventDefault();

    // 固定帧率更新物理逻辑
    setInterval(() => {
      updatePhysics();
    }, 1000 / 15); // 每秒15次物理更新

    function gameLoop() {
      drawMap();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
